'use strict';

const RequestResponseController = require('castv2-client').RequestResponseController;

const BrowserController = class BrowserController extends RequestResponseController {
	constructor(client, sourceId, destinationId) {
		super(client, sourceId, destinationId, 'urn:x-cast:' + BrowserController.APP_URN);

		const onmessage = (data, broadcast) => {
			console.log('YoutubeController got message', data, broadcast);
			if (data.type === 'MEDIA_STATUS') {
				this.emit('status', data.status);
				if (data.status === 'ENDED') {
					this.emit('disconnect');
				}
			}
		}

		const onclose = () => {
			this.removeListener('message', onmessage);
		}

		this.on('message', onmessage);
		this.once('close', onclose);
	}

	loadVideo(youtubeId, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		}

		const args = Object.assign({ youtubeId }, options);

		this.request({ command: 'loadYoutube', args }, callback);
	}

	loadPlaylist(youtubePlaylistId, options, callback) {
		if (typeof options === 'function') {
			callback = options;
			options = {};
		}

		const args = Object.assign({ youtubePlaylistId }, options);

		this.request({ command: 'loadYoutubePlaylist', args }, callback);
	}

	getStatus(callback) {
		this.request({ command: 'getStatus' }, callback);
	}

	play(callback) {
		this.request({ command: 'play' }, callback);
	}

	pause(callback) {
		this.request({ command: 'pause' }, callback);
	}

	previous(callback) {
		this.request({ command: 'previous' }, callback);
	}

	next(callback) {
		this.request({ command: 'next' }, callback);
	}

	stop(callback) {
		this.request({ command: 'stop' }, callback);
	};

	shuffle(shuffle, callback) {
		this.request({ command: 'shuffle', args: { shuffle } }, callback);
	};

	loop(loop, callback) {
		this.request({ command: 'loop', args: { loop } }, callback);
	};

	seek(time, callback) {
		this.request({ command: 'seek', args: { time: time } }, callback);
	};

}

module.exports = BrowserController;
